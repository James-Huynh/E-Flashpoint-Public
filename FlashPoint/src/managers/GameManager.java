package managers;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
// Start of user code for imports
import java.util.*;
// End of user code

import actions.Action;
import actions.Chop;
import actions.Extinguish;
import actions.Finish;
import actions.Handle;
import actions.Move;
import actions.MoveWithVictim;
import game.GameState;
import lobby.Lobby;
import old_interface.RunFlashPoint;
import server.Player;
import tile.ParkingSpot;
import tile.Tile;
import token.*;
import edge.*;

/**
 * GameManager class definition.
 * Generated by the TouchCORE code generator.
 * modified by @matekrk @eric
 */
public class GameManager {
    
	//changes by ben
	//private final GameState gs = GameState.getInstance();
	private GameState gs;
	private Set<Action> possibleActions = generateAllPossibleActions();
	
	// MAIN
    public void runFlashpoint() {
    	// list of Players from lobby - somehow getLobby from Server-Client connection
    	Lobby lobby = new Lobby(); //dumb lobby for now
    	gs.updateGameStateFromLobby(lobby);
    	setup();
    	doTurns();
    }
    
    public GameManager(GameState input) {
    	gs = input;
    }
    
    public void setup() {
    	// we have board at this stage
    	// in order:
    	// DOOR, FIRE, POI, DAMAGE_TOKENS, PLAYERS' POSITION
    	
        /* TODO: No message view defined */
    }
	
    public void doTurns() {
    	return;
    	/*
    	while(!gs.isGameTerminated()) {
    		gs.getPlayingFirefighter().setAP( Math.min(8, gs.getPlayingFirefighter().getAP() + 4) );
    		takeATurn();
    		advanceFire();
    		gs.setActiveFireFighterIndex( (gs.getActiveFireFighterIndex() + 1)%(gs.getFireFighterList().size()) );
    	}
    	System.out.println(gs.isGameWon());
    	*/
    }
    
    public void takeATurn() {
    	Set<Action> availableActions = getAllAvailableActions();
    	// pass to GUI
    	// GUI passes which action
    	// perform 
    	// if it was end of turn die, if not recursion (but GameState is different now!)	
    }
    
    public Set<Action> generateAllPossibleActions(){
    	
    	Set<Action> allPossibleActions = new HashSet<Action>(30);
    	
    	//move + chop + handle
    	for (int dir : new int[]{0,1,2,3} ) {
    		allPossibleActions.add(new Move(dir));
    		allPossibleActions.add(new MoveWithVictim(dir));
    		allPossibleActions.add(new Chop(dir, 2));
    		allPossibleActions.add(new Chop(dir, 4));
    		allPossibleActions.add(new Handle(dir));
    	}
    	
    	//extinguish
    	for (int dir : new int[]{-1,0,1,2,3,} ) {
    		allPossibleActions.add(new Extinguish(dir, 1)); 
    		allPossibleActions.add(new Extinguish(dir, 2));
    	}
 
//    	//handle
//    	allPossibleActions.add(new Handle());
    	
    	//finish
    	allPossibleActions.add(new Finish());
    	
    	//
    	return allPossibleActions;
    }
    
    //TODO: Zaid + Mat based on validations
    public Set<Action> getAllAvailableActions() {
    	Set<Action> allValidActions = new HashSet<Action>(30);
        for (Action a : possibleActions) {
        	if (a.validate(gs)) {
        		allValidActions.add(a);
        	}
        }
        return allValidActions;
    }
    
    public void setAllAvailableActions(Set<Action> newSet) {
    	this.possibleActions = newSet;
    }
    
    
	//Ben and eric, ready for testing
    public void explosion(Tile targetTile) {
        /*
         * Ben: Can u remember how we consider the tile check? From the first tile or the 0th Tile?
         * I can not remember here need some modification
         * By Eric
         * 
         * */
    	for(int direction = 0; direction < 4; direction++) {
    		
    		
    		boolean checkBarriers = targetTile.checkBarriers(direction);
    		
    		Edge targetEdge;
    		
    		//checks if the wall or door that is the next edge in this direction is closed or intact. Explosion halts here
    		if(checkBarriers == true) {
    			targetEdge = targetTile.getEdge(direction);
    			
    			if(targetEdge.isDoor()) {
    				
    				targetEdge.destroyDoor();
    				//continue instead of break, to check the next direction but continue the explosion
    				continue;
    			} 
    			else if(targetEdge.isWall()) {
    				//wall is only damaged 1 for family game
    				targetEdge.chop();
    				gs.updateDamageCounter();
    				//continue instead of break, to check the next direction but continue the explosion
    				continue;
    			}
    		}
    			
			//destroys the open door but the explosion continues through the door.
			if(targetTile.getEdge(direction).isDoor()) {
				if(!targetTile.getEdge(direction).isDestroyed()) {
					targetTile.getEdge(direction).destroyDoor();
				}
			}
			
			Tile tempTile = gs.getNeighbour(targetTile, direction);
			
			
			while(true) {
				//updates final tile of explosion
				if(tempTile.getFire()<2) {
					
					tempTile.setFire(2);
					
					break;
				} 
				
				//halts the explosion from leaving the board
				if(!tempTile.checkInterior()) {
					break;
				}
				
				boolean barCheck = tempTile.checkBarriers(direction);
				//destroyed or damages walls in the way
				if(barCheck == true) {
					targetEdge = tempTile.getEdge(direction);
					
					if(targetEdge.isDoor()) {
						
						targetEdge.destroyDoor();
						break;
					} 
					else if(targetEdge.isWall()) {
						
						targetEdge.chop();
						
						gs.updateDamageCounter();
						
						break;
					}
				}
				
				//destroys the open door if the explosion is passing through.
				if(tempTile.getEdge(direction).isDoor()) {
					if(!tempTile.getEdge(direction).isDestroyed()) {
						tempTile.getEdge(direction).destroyDoor();
					}
				}
				
				//gets the next tile
				tempTile = gs.getNeighbour(tempTile, direction);
			}
    		
    	}
    }

  //Ben and eric, ready for testing
    public void resolveFlashOver() {
        /* TODO: No message view defined */
    	Tile targetTile = gs.returnTile(0,0);
    	int[] tempCoords = targetTile.getCoords();
    	while(true) {       // all tiles
    		int curFire = targetTile.getFire();
    		tempCoords = targetTile.getCoords();
    		if(curFire == 1) { //checking if the tile is smokey, if so it will check adj tiles to see if it should be set on fire
    			
    			for(int direction=0; direction<4;direction++) {
    				//checks for if the adj tiles are above/below the map
    				if(tempCoords[0] == 0) {
    					if(direction == 1) {
    						continue;
    					}
    				} else if(tempCoords[0] == 7) {
    					if(direction == 3) {
    						continue;
    					}
    				}
    				//checks for if the adj tiles are left or right of the map
    				if(tempCoords[1] == 0) {
    					if(direction == 0) {
    						continue;
    					}
    				} else if(tempCoords[1] == 9) {
    					if(direction == 2) {
    						continue;
    					}
    				}
    				
    				//checks if a barrier is in the way, if not it checks if the tile in said direction is on fire and flashes over is so
    				boolean checkBarriers = targetTile.checkBarriers(direction);
    				if(checkBarriers == false) {
    					Tile adjTile =  gs.getNeighbour(targetTile,direction);
        				int fireCheck = adjTile.getFire();
        				
        				if(fireCheck == 2) {
        					targetTile.setFire(2);
        					
        					//resets the targetTile
        					targetTile = gs.returnTile(0,0);
        		
        					break;
        				}
    				}
    			}
    		
    			//halts the loop when the last tile is looked at
        		if(tempCoords[0] == 7 && tempCoords[1] == 9) {
        			break;
        		}
        		
        		//selects the next tile either by getneighbour or the first column of the next row if at the end of the current
        		if(tempCoords[1] == 9) {
        			targetTile = gs.returnTile(tempCoords[0] + 1, 0);
        		}else {
        			targetTile = gs.getNeighbour(targetTile, 2);
        		}
        		
    		} 
    		//the tile being looked at is not smokey, get the next tile
    		else {
    			if(tempCoords[0] == 7 && tempCoords[1] == 9) {
    				break;
    			}
    			if(tempCoords[1] == 9) {
        			targetTile = gs.returnTile(tempCoords[0] + 1, 0);
        		}else {
        			targetTile = gs.getNeighbour(targetTile, 2);
        		}
    		}
    		
    	}
    	
    }

  //Ben and eric, skeleton code 
    public void checkKnockDowns() {
        /* TODO: No message view defined */
    	//Select Tile
    	Tile targetTile = gs.returnTile(0, 0);
    	
    	//Check Tile contents
    	boolean containsFireFighter = targetTile.containsFirefighter();
    	boolean containsPOI = targetTile.containsPOI();
    	
    	//cycle through all the tile, need a better check.
    	int[] coords = targetTile.getCoords();
    
    	while(true){	
    		int curFire = targetTile.getFire();
    		coords = targetTile.getCoords();
    		boolean fire = false;
    		
    		//knockdown all firefighters on tiles with fire
    		
    		if(containsFireFighter == true) {
    			
    			if(curFire == 2) {
    				fire = true;
    				ParkingSpot respawnTile = targetTile.getNearestAmbulance();
    				
    				Firefighter tempFire = targetTile.removeFirstFireFighter();
    				Tile target = respawnTile.getTiles()[0];
    				tempFire.updateLocation(respawnTile);
    				target.addToFirefighterList(tempFire);
    			}
    		}
    		//kill and remove all POI found on tiles with fire
    		if(containsPOI == true) {
    			if(curFire == 2) {
    				fire = true;
    				POI tempPOI = targetTile.removeFirstPoi();
    				gs.removePOI(tempPOI);
    				if(tempPOI.isVictim()) {
    					gs.updateLostCount(tempPOI);
    				} else {
    					gs.updateRevealPOI(tempPOI);
    				}
    			}
    		}
    		
    		//check if this tile still have POI or firefighters
    		containsFireFighter = targetTile.containsFirefighter();
        	containsPOI = targetTile.containsPOI();
        	
        	//select next tile if current tile is empty
        	if((!containsFireFighter && !containsPOI)|| (containsFireFighter && !fire) || (containsPOI && !fire)) {
        		
        		
        		if(coords[0] == 7 && coords[1] == 9) {
    				break;
    			}
    			if(coords[1] == 9) {
        			targetTile = gs.returnTile(coords[0] + 1, 0);
        		}else {
        			targetTile = gs.getNeighbour(targetTile, 2);
        		}
        		
        		containsFireFighter = targetTile.containsFirefighter();
            	containsPOI = targetTile.containsPOI();
        	}
    		
    	}
    }

  //Ben and eric, skeleton code 
    public void placePOI() {
        int currentPOI = gs.getCurrentPOI();
        while (currentPOI < 3) {
        	Tile targetTile = gs.rollForTile();
        	boolean containsPOI = targetTile.containsPOI();
        	boolean containsFireFighter = targetTile.containsFirefighter();
        	int curFire = targetTile.getFire();
        	if(containsPOI == false) {
        		//could skip this if else and just set fire to 0 every time, could also write this to check tile and so on and only add the poi if the tile does not contain a firefighter or if it does and the poi is a victim.
        		if(curFire != 0) {
        			targetTile.setFire(0);
        			POI newPOI = gs.generatePOI();
        			targetTile.addPoi(newPOI);
        			gs.updatePOI(newPOI);
        			
        			if(containsFireFighter == true) {
        				newPOI.reveal();
        				if(newPOI.isVictim() == false) {
        					//change to remove POI
        					targetTile.removeFromPoiList(newPOI);
        					gs.removePOI(newPOI);
        					gs.updateRevealPOI(newPOI);
        				}
        			}
        		}
        		else if(curFire == 0) {
        			POI newPOI = gs.generatePOI();
        			targetTile.addPoi(newPOI);
        			gs.updatePOI(newPOI);
        			if(containsFireFighter == true) {
        				newPOI.reveal();
        				if(newPOI.isVictim() == false) {
        					//change to remove POI
        					targetTile.removeFromPoiList(newPOI);
        					gs.removePOI(newPOI);
        					gs.updateRevealPOI(newPOI);
        				}
        			}
        		}
        	}
        	currentPOI = gs.getCurrentPOI();
        }
    }

    //Ben and eric, skeleton code 
    public void advanceFire() {
        /* TODO: No message view defined */
    	//gs.endTurn();
    	
    	Tile targetTile = gs.rollForTile();
    	
    	int curFire = targetTile.getFire();
    	
    	if(curFire == 0) {
    		int[] tempCoords = targetTile.getCoords();
    		boolean flag = false;
    		for(int direction = 0; direction<4; direction ++) {
    			//checks for if the adj tiles are above/below the map
				if(tempCoords[0] == 0) {
					if(direction == 1) {
						continue;
					}
				} else if(tempCoords[0] == 7) {
					if(direction == 3) {
						continue;
					}
				}
				//checks for if the adj tiles are left or right of the map
				if(tempCoords[1] == 0) {
					if(direction == 0) {
						continue;
					}
				} else if(tempCoords[1] == 9) {
					if(direction == 2) {
						continue;
					}
				}
				//checks if a barrier is in the way, if not it checks if the tile in said direction is on fire and flashes over is so
				boolean checkBarriers = targetTile.checkBarriers(direction);
				if(checkBarriers == false) {
					Tile adjTile =  gs.getNeighbour(targetTile,direction);
    				int fireCheck = adjTile.getFire();
    				
    				if(fireCheck == 2) {
    					flag = true;
    				}
				}
    		}
    		if(flag) {
    			targetTile.setFire(2);
    		}else {
    			targetTile.setFire(1);
    		}
    	}else if(curFire == 1) {
    		targetTile.setFire(2);
    	}
    	else {
    		explosion(targetTile);
    	}
    	resolveFlashOver();
    	checkKnockDowns();
    	placePOI();
    	clearExteriorFire();
    	
    	
    	
    	int wallCheck = gs.getDamageCounter();//should this running the same time with the main process? @Eric
    	int victimCheck = gs.getLostVictimsList().size();
    	int savedVictimCheck = gs.getSavedVictimsList().size();
    	
    	
    	if(wallCheck >= 24 || victimCheck >= 4) {
    		gs.terminateGame();
    	} else if(savedVictimCheck >= 7) {
    		gs.winGame();
    	}
    }
   
    private void clearExteriorFire() {
		for(int i = 0; i<8; i++) {
			gs.returnTile(i,0).setFire(0);
			gs.returnTile(i, 9).setFire(0);
		}
		for(int i = 0; i<10; i++) {
			gs.returnTile(0,i).setFire(0);
			gs.returnTile(7, i).setFire(0);
		}
		
	}

	public int[] nextTile(int x, int y, int direction) {
    	int[] result = new int[2];
    	if(y==8) {
    		if(x == 6) {
    			result[0] = 1;
    			result [1] = 1;
    			return result;
    		}
    		result[0] = x+1;
    		result[1] = 1;
    		return result;
    	}
    	result[0] = x;
    	result[1] = y+1;
    	return result;
    }

    /*
     * SAVING AND READING
     */
    
    //This one I save for our next meeting. key word *serialization* @matekrk
    public void saveGame() {
    	try {
			FileOutputStream fo = new FileOutputStream(new File("myGameState.txt"));
			ObjectOutputStream oo = new ObjectOutputStream(fo);

			// Write object to file
			oo.writeObject(gs);

			oo.close();
			fo.close();


		} catch (FileNotFoundException e) {
			System.out.println("File not found");
		} catch (IOException e) {
			System.out.println("Error initializing stream");
		}
    }
    
    public GameState loadGame() {
    	try {
    		FileInputStream fi = new FileInputStream(new File("myGameState.txt"));
			ObjectInputStream oi = new ObjectInputStream(fi);
			// Read objects
			GameState gs1 = (GameState) oi.readObject();

			System.out.println(gs1.toString());

			oi.close();
			fi.close();
			
			gs.updateGameStateFromObject(gs1);
			return gs1; //if not void
			
			} catch (FileNotFoundException e) {
				System.out.println("File not found");
			} catch (IOException e) {
				System.out.println("Error initializing stream");
			} catch (ClassNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
    	return null;
    }
    
    

    //any volunteers? I guess we can do that when GUI is done
    public void setOptions() {
        /* TODO: No message view defined */
    }
    
//    public static void main(String[] args) {
//    	GameManager gm = new GameManager();
//    	gm.runFlashpoint();
////    	gm.gs.toString();
//    	
//    }
 
}
