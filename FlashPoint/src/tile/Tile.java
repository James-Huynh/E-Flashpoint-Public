package tile;

import java.util.ArrayList;
import java.util.Arrays;

import edge.Edge;
import token.Firefighter;
import token.POI;
import game.GameState;

/**
 * Tile class definition.
 * Generated by the TouchCORE code generator.
 * modified by @matekrk
 */
public class Tile{
    
    protected int fire;
    protected int[] coords;
    protected boolean interior;
    protected Edge[] adjacentEdges;
    protected ArrayList<Firefighter> listOfFirefighters;
    protected int x;
    protected int y;
    protected ArrayList<POI> poiList;
    protected boolean isInterior;
    protected ParkingSpot pointerParkingSpot; 
    protected ParkingSpot nearestAmbulance;
    
    public Tile(boolean isInterior, int[] coords) {
        this.x = coords[0];
        this.y = coords[1];
        this.isInterior = isInterior;
    }

    /*
     * GETTERS
     */
    
    public int getFire() {
        return fire;
    }

    public boolean containsFirefighter() {
        /* TODO: No message view defined */
        return !(listOfFirefighters.isEmpty());
    }

    public boolean containsPOI() {
        /* TODO: No message view defined */
    	return !(poiList.isEmpty());
    }

    public ArrayList<POI> getPoiList() {
        return poiList;
    }

    public ArrayList<Firefighter> getFirefighterList() {
        return listOfFirefighters;
    }
    
    public int[] getCoords() {
        return new int[] {x,y};
    }

    public boolean getInterior() {
    	return interior;
    }
    
    public void setEdge(int direction, Edge e) {
    	adjacentEdges[direction] = e;
    }
    //left: 0, top: 1, right: 2, down: 3
    public Edge getEdge(int direction) {
    	return adjacentEdges[direction];
    }
    
    public int getX() {
    	return x;
    }
    
    public int getY() {
    	return y;
    }
    
    public ParkingSpot getParkingSpot() {
    	return pointerParkingSpot;
    }
    
    /*
     * SETTERS
     */
    
    public void setFire(int amount) {
    	if (amount <= 2 && amount >=0) {
    		fire = amount;
    	}
    }

    public void setPOIList(ArrayList<POI> poiList) {
    	this.poiList = poiList;
    }
    
    public void addPoi(POI newPoi) {
        poiList.add(newPoi);
    }
    
    public POI removeFirstPoi() {
    	return poiList.remove(0);
    }

    public void removeFromFirefighterList(Firefighter target) {
        listOfFirefighters.remove(target);
    }
    
    
    public void addToFirefighterList(Firefighter target) {
    	listOfFirefighters.add(target);
    }
    
    public Firefighter removeFirstFireFighter() {
    	return listOfFirefighters.remove(0);
    }

    public void setCoords(int[] coords) {
        x = coords[0];
        y = coords[1];
    }
    
    public void setParkingSpot(ParkingSpot pointerParkingSpot) {
    	this.pointerParkingSpot = pointerParkingSpot;
    }
    
    /*
     * some algos/methods
     */
    

    public boolean checkBarriers(int direction) {
        /* TODO: No message view defined */
    	if(this.getEdge(direction).isDoor()) {
    		return true;
    	}else if(this.getEdge(direction).isWall()) {
    		return true;
    	}
        return false;
    }

    //good shit!
    //may need to have this give two, in the chance that the player is equally in between two parking spots and should be given the choice of respawning.
    public ParkingSpot getNearestAmbulance() {
        /* TODO: No message view defined */
        return this.nearestAmbulance;
    }


    public void removeFromPoiList(POI target) {
        poiList.remove(target);
    }

	public void increaseToFire() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public String toString() {
		return "Tile [fire=" + fire + ", coords=" + Arrays.toString(coords) + ", interior=" + interior
				+ ", adjacentEdges=" + Arrays.toString(adjacentEdges) + ", listOfFirefighters=" + listOfFirefighters
				+ ", x=" + x + ", y=" + y + ", poiList=" + poiList + ", isInterior=" + isInterior
				+ ", pointerParkingSpot=" + pointerParkingSpot + "]";
	}

	
}
